import scala.math.sqrt
import scala.util.Random

object KMeans {
  /** *
    * Compute cosine similarity between two documents
    *
    * @param doc1
    * @param doc2
    * @return cosine similarity
    */

  private def cosineSimilarity(doc1: ParsedDocument, doc2: ParsedDocument): Double = {

    // Documents vectors of different length should not occur. If there are documents of different length then they are
    // not similar and return 0
    if (doc1.words.length != doc2.words.length) {
      return 0d
    }

    // Compute numerator of cosine similarity
    val numerator = (doc1.words, doc2.words).zipped.map((wordMap1, wordMap2) => wordMap1.weight * wordMap2.weight).sum

    //Compute denominator of cosine similarity
    val denominator = sqrt(doc1.words.map(wordMap => wordMap.weight * wordMap.weight).sum) *
      sqrt(doc2.words.map(wordMap => wordMap.weight * wordMap.weight).sum)

    //Avoid inifity and return 0 if denominator is 0
    if (denominator == 0) {
      return 0
    }

    //Compute cosine similarity
    val cosSim = numerator / denominator
    cosSim
  }


  /** *
    * Initiliaze K-Means algorithm by randomly selecting @num_cluster documents as initial centroids.
    *
    * @param documents   List of all documents in the corpus
    * @param num_cluster Number of cluster to generated by K-Means algorithm
    * @return List of centroids
    */
  def initializeKmeans(documents: List[ParsedDocument], num_cluster: Int): List[ParsedDocument] = {
    (0 until num_cluster).map(_ => documents(Random.nextInt(documents.length))).toList
  }

  /** *
    * Find the cluster that is closest to the given documents
    *
    * @param d         Document for which the closest cluster has to found
    * @param centroids List of centroids of each cluster
    * @return Index of the assigned cluster
    */
  def closestCluster(d: ParsedDocument, centroids: List[ParsedDocument]): Int = {
    centroids.map(centroid => cosineSimilarity(centroid, d)).zipWithIndex.maxBy(_._1)._2
  }

  /** *
    * Assign cluster to each document based on its distance from the centroid
    *
    * @param centroids List of centroid for clusters
    * @param documents List of all documents in the corpus
    * @return Map of cluster index that stores the documents belonging to the same cluster
    */
  def assignCluster(centroids: List[ParsedDocument], documents: List[ParsedDocument]): Map[Int, List[ParsedDocument]] = {
    val clusterGroup = documents.groupBy(closestCluster(_, centroids))

    centroids.zipWithIndex.map { case (centroid, index) => index -> clusterGroup.getOrElse(index, List()) }.toMap
  }


  /** *
    * Given a list of documents in the cluster. Compute a centroid for that cluster
    *
    * @param documents         List of documents that belong to the cluster
    * @param originalDocuments List of all documents in the corpus
    * @return New centroid
    */
  def computeCentroid(documents: List[ParsedDocument], originalDocuments: List[ParsedDocument]): ParsedDocument = {

    //If current cluster does not have any document. Randomly select another document from the corpus as centroid.
    if (documents.isEmpty) {
      return originalDocuments(Random.nextInt(originalDocuments.length))
    }

    val wordCountInCluster = documents.flatMap(doc => doc.words).groupBy(wordMap => wordMap.word)
      .map {
        case (word, wordsinAllDocs) => WordMap(word, wordsinAllDocs.map(wordMap1 => wordMap1.weight).sum)
      }.toList.sortBy(wordMap => wordMap.word)


    ParsedDocument("", wordCountInCluster.map(wordMap => WordMap(wordMap.word, wordMap.weight / documents.length)))
  }

  /** *
    * Update centroid for all cluster based on cluster assignment of the documents
    *
    * @param cluster
    * @param centroids
    * @param documents
    * @return New centroid for all clusters
    */
  def updateCentroid(cluster: Map[Int, List[ParsedDocument]], centroids: List[ParsedDocument], documents: List[ParsedDocument]): List[ParsedDocument] = {

    centroids.zipWithIndex.map { case (centroid, index) => computeCentroid(cluster.getOrElse(index, List()), documents) }

  }

  /** *
    * Check if K-Means has converged. The algorithm has converged if the shift in centroid is less than a very small
    * threshold.
    *
    * @param centroids    List of old centroid
    * @param newCentroids List of new centroid
    * @return true if algorithm has converged.
    */

  def converged(centroids: List[ParsedDocument], newCentroids: List[ParsedDocument]): Boolean = {

    val shift = centroids.zip(newCentroids).map {
      case (oldCentroid, newCentroid) =>
        oldCentroid.words.zip(newCentroid.words).map {
          case (oldWordMap, newWordMap) => Math.pow(oldWordMap.weight - newWordMap.weight, 2)
        }.sum
    }.sum

    shift < 1E-9
  }

  /** *
    * Run a single step K-Means algorithm i.e. assign documents to cluster and update the centroids of clusters based
    * on this new assignment.
    *
    * @param documents List of all documents in the corpos
    * @param centroids List of centroid for all clusters
    * @return new centroid of the clusters
    */
  private def run(documents: List[ParsedDocument], centroids: List[ParsedDocument]): List[ParsedDocument] = {

    val cluster = assignCluster(centroids, documents)
    updateCentroid(cluster, centroids, documents)
  }

  /** *
    * Initialize cluster and run K-Means until convergence.
    *
    * @param documents
    * @param num_cluster
    * @return Clustered documents.
    */
  def cluster(documents: List[ParsedDocument], num_cluster: Int): Map[Int, List[ParsedDocument]] = {
    val num_docs = documents.length

    //Initialize cluster
    var centroids = initializeKmeans(documents, num_cluster)

    // Assign documents to cluster and compute new centroid
    var newCentroids = run(documents, centroids)

    // Iterate until convergence
    if (!converged(centroids, newCentroids)) {
      centroids = newCentroids
      newCentroids = run(documents, centroids)
    }

    assignCluster(newCentroids, documents)
  }
}
